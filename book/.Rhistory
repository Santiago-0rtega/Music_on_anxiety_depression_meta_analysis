# 'ROM' (Ratio of Means) for independent groups.
effect <- metafor::escalc(measure = "ROM", n1i = Ex_n, n2i = C_n,
m1i = Ex_mean, m2i = C_mean, sd1i = Ex_SD, sd2i = C_SD,
var.names = c("lnRR", "lnRR_var"))
} else if (Comparison_structure == "Dependent") {
# 'ROMC' (Ratio of Means, Correlated) for dependent/repeated groups,
# using an assumed correlation (ri = 0.5).
effect <- metafor::escalc(measure = "ROMC", ni = (Ex_n + C_n) / 2,
m1i = Ex_mean, m2i = C_mean, sd1i = Ex_SD, sd2i = C_SD,
ri = 0.5, var.names = c("lnRR", "lnRR_var"))
}
# Assign the calculated lnRR and its variance to the new columns.
dt1$lnRR[i] <- effect$lnRR
dt1$lnRR_var[i] <- effect$lnRR_var
# 2. Outcome Direction Standardization (Sign Flip)
# If 'Higher_better' is "No" (e.g., lower anxiety is better), we flip the sign
# of lnRR so that a positive value always indicates a beneficial outcome.
if (Higher_better == "No") {
dt1$lnRR[i] <- dt1$lnRR[i] * -1
}
}
# --- B. Proportion Data (Data_type is Percentage) ---
else if (Data_type %in% c("percentage")) {
# *** CRITICAL FIX: CONDITIONAL RESCALING ***
# Only rescale if the study is NOT "es018," as "es018" reports 0-1 proportions.
# All other studies report 0-100 percentages and must be divided by 100.
if (current_es_id != "es018") {
Ex_mean <- Ex_mean / 100
C_mean <- C_mean / 100
Ex_SD <- Ex_SD / 100
C_SD <- C_SD / 100
}
# 1. Standardization: Adjust means if "Higher_better" is "No"
# Flips the proportion (e.g., 80% success becomes 20% failure) to standardize direction.
if (Higher_better == "No") {
Ex_mean <- 1 - Ex_mean
C_mean <- 1 - C_mean
}
# 2. Transform SDs
# Calculate the standard deviation of the arcsin-transformed data (SD') based on the formula:
# SD' = sqrt(SD^2 / (4 * p * (1 - p)))
Ex_SD_trans <- sqrt(Ex_SD^2 / (4 * Ex_mean * (1 - Ex_mean)))
C_SD_trans  <- sqrt(C_SD^2 / (4 * C_mean * (1 - C_mean)))
# 3. Transform Means (M') using the arcsin(sqrt(p)) function
Ex_mean_trans <- asin_trans(Ex_mean)
C_mean_trans <- asin_trans(C_mean)
# 4. lnRR Calculation (Using transformed means)
# lnRR = ln(M'ex / M'control)
lnRR_pro_calc <- log(Ex_mean_trans / C_mean_trans)
# 5. Variance Calculation (Using transformed SDs)
# Calculate the independent variance components (V_Ex, V_C) using the transformed values.
V_Ex <- (Ex_SD_trans)^2 * (1 / (Ex_mean_trans^2 * Ex_n))
V_C  <- (C_SD_trans)^2 * (1 / (C_mean_trans^2 * C_n))
if (Comparison_structure == "Independent") {
# Variance for independent groups is simply the sum of individual variances.
lnRR_var_pro <- V_Ex + V_C
} else if (Comparison_structure == "Dependent") {
# Variance for dependent groups includes a covariance term based on rho = 0.5.
# V_dep = V_Ex + V_C - 2 * rho * sqrt(V_Ex * V_C)
lnRR_var_pro <- V_Ex + V_C - 2 * 0.5 * sqrt(V_Ex) * sqrt(V_C)
}
# Final assignment of results for proportional data.
dt1$lnRR[i] <- lnRR_pro_calc
dt1$lnRR_var[i] <- lnRR_var_pro
}
}
return(dt1)
}
#| label: load_and_clean_data
db <- readr::read_csv(here("..","data","db251124.csv")) %>%
# Convert all columns required for lnRR calculation to numeric.
mutate(across(c(C_n, Ex_n, C_mean, Ex_mean, C_SE, Ex_SE, C_SD, Ex_SD), as.numeric)) %>%
mutate(
# Calculate C_SD where it is missing but C_SE is present
C_SD = ifelse(
is.na(C_SD) & !is.na(C_SE),
C_SE * sqrt(C_n),
C_SD
),
# Calculate Ex_SD where it is missing but Ex_SE is present
Ex_SD = ifelse(
is.na(Ex_SD) & !is.na(Ex_SE),
Ex_SE * sqrt(Ex_n),
Ex_SD
)
) %>%
#
# This combines Study_ID and Ex_ID to uniquely identify the source cohort.
mutate(
Cohort_ID = paste(Study_ID, "Ex-ID", sep = "_")
) %>%
# Convert all remaining character columns to factors (for meta-regression)
mutate(across(where(is.character), as.factor))
#| label: calculate_effect_sizes
#| eval: false
db_effect_sizes<-calculate_lnRR(db)
readr::write_csv(
db_effect_sizes,
file = here("..","data", "db_lnRR.csv"),
na = ""
)
#| label: effect_size_table
#| echo: false
db_effect_sizes <- readr::read_csv(here("..","data","db_lnRR.csv")) %>%
mutate(across(c(C_n, Ex_n, C_mean, Ex_mean, C_SE, Ex_SE, C_SD, Ex_SD), as.numeric))%>%
mutate(across(where(is.character), as.factor))
# Define all columns to display (IDs first, then numerical data)
display_cols <- c("ES_ID", "Study_ID",
"C_n", "C_mean", "C_SE", "C_SD",
"Ex_n", "Ex_mean", "Ex_SE", "Ex_SD",
"lnRR", "lnRR_var", "Cohort_ID")
# Define columns that require numerical rounding (excluding the ID columns)
round_cols <- c("C_n", "C_mean", "C_SE", "C_SD",
"Ex_n", "Ex_mean", "Ex_SE", "Ex_SD",
"lnRR", "lnRR_var")
DT::datatable(
db_effect_sizes %>%
# Select only the desired columns for display
dplyr::select(all_of(display_cols)),
options = list(
pageLength = 10,
scrollX = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv')
),
extensions = 'Buttons',
rownames = FALSE
) %>%
# Apply rounding ONLY to the numerical statistical columns
formatRound(columns = round_cols, digits = 3) %>%
# Apply general styling to all displayed columns
formatStyle(columns = display_cols, `text-align` = 'center')
#| label: lnRR_histogram
hist(db_effect_sizes$lnRR,xlim=c(-6.5,9),breaks = seq(-6.5,9,0.5))
hist(db_effect_sizes$lnRR_var, xlim=c(0,13),breaks = seq(0,13,0.1))
#| label: load_and_clean_data
db <- readr::read_csv(here("..","data","db_lnRR.csv")) %>%
mutate(across(c(C_n, Ex_n, C_mean, Ex_mean, C_SE, Ex_SE, C_SD, Ex_SD,lnRR,lnRR_var), as.numeric))%>%
mutate(across(where(is.character), as.factor))
db$Cohort_ID <- interaction(db$Study_ID, db$ES_ID, drop = TRUE)
db$Cohort_ID <- interaction(db$Study_ID, db$ES_ID, drop = TRUE)
max(with(db, table(Study_ID, Ex_ID, Outcome_ID, Comparison)))
max(with(db, table(Study_ID, Ex_ID, Outcome_ID, Comparison, Test_sequence)))
tab <- with(db, table(Study_ID, Ex_ID, Outcome_ID, Comparison, Test_sequence))
idx <- which(tab > 1, arr.ind = TRUE)
problem_keys <- data.frame(
Study_ID      = dimnames(tab)[[1]][idx[,1]],
Ex_ID         = dimnames(tab)[[2]][idx[,2]],
Outcome_ID    = dimnames(tab)[[3]][idx[,3]],
Comparison    = dimnames(tab)[[4]][idx[,4]],
Test_sequence = dimnames(tab)[[5]][idx[,5]],
n             = tab[idx]
)
problem_keys
problem_rows <- merge(
db,
problem_keys[, c("Study_ID","Ex_ID","Outcome_ID","Comparison","Test_sequence")],
by = c("Study_ID","Ex_ID","Outcome_ID","Comparison","Test_sequence"),
all = FALSE
)
problem_rows[order(problem_rows$Study_ID, problem_rows$Ex_ID, problem_rows$Outcome_ID,
problem_rows$Comparison, problem_rows$Test_sequence),
]
problem_rows %>%
dplyr::group_by(Study_ID, Ex_ID, Outcome_ID, Comparison, Test_sequence) %>%
dplyr::summarise(
n = dplyr::n(),
n_unique_yi = dplyr::n_distinct(lnRR),
n_unique_vi = dplyr::n_distinct(lnRR_var),
.groups = "drop"
)
db$Cohort_ID <- interaction(db$Study_ID, db$Ex_ID, drop = TRUE)
db$Endpoint_ID <- interaction(
db$Assay_type,       # NEW (EPM, Sucrose, ...)
db$Outcome_ID,     # within-assay outcome index OR metric id
db$Test_sequence,
drop = TRUE
)
max(with(db, table(Cohort_ID, Comparison, Endpoint_ID)))
install.packages("multcomp")
#| label: setup
#| include: false
pacman::p_load(
DT,
dtplyr,
here,
knitr,
tidyverse,
patchwork,
metafor,
orchaRd, multcomp,
)
#| label: load_and_clean_data
db <- readr::read_csv(here("..","data","db_lnRR.csv")) %>%
mutate(across(c(C_n, Ex_n, C_mean, Ex_mean, C_SE, Ex_SE, C_SD, Ex_SD), as.numeric))%>%
mutate(across(where(is.character), as.factor))
VCV <- metafor::vcalc(
vi = lnRR_var,
cluster = Cohort_ID, # The clustering variable (Study_ID + Ex_ID)
obs = ES_ID,         # The unique observation/effect size ID
rho = 0.5,           # Assumed correlation between outcomes from the same cohort
data = db
)
#| label: filter_outcome_type
#| fold: TRUE
k_counts <- db %>%
group_by(Outcome_type) %>%
summarise(k_es = n())
levels_to_keep <- k_counts %>%
filter(k_es >= 5) %>%
pull(Outcome_type)
db_filtered <- db %>%
filter(Outcome_type %in% levels_to_keep)
indices_to_keep <- which(db$Outcome_type %in% levels_to_keep)
VCV_filtered <- VCV[indices_to_keep, indices_to_keep]
#| label: model_lifestage_exp
mLE <- rma.mv(yi = lnRR,
V = VCV,
mods = ~ Lifestage_exposure-1,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db)
summary(mLE)
r2LE <- round(r2_ml(mLE), 4)
r2LE
summary(glht(mLE, linfct=cbind(contrMat(rep(1,6), type="Tukey"))), test=adjusted("none"))
#| label: orchard_lifestage_exp
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_lifestage<-orchard_plot(mLE,
mod = "Lifestage_exposure",
group = "Study_ID",
xlab = "lnRR",
flip = FALSE) +
scale_colour_brewer(palette = "Set1") +
scale_fill_brewer(palette = "Dark2")+scale_y_continuous(breaks = seq(-8, 10, by = 2),
minor_breaks = seq(-8, 10, by = 1 ))
orchard_lifestage
#| label: filter_sex
#| fold: TRUE
k_counts <- db %>%
group_by(Sex) %>%
summarise(k_es = n())
levels_to_keep <- k_counts %>%
filter(k_es >= 5) %>%
pull(Sex)
db_filtered <- db %>%
filter(Sex %in% levels_to_keep)
indices_to_keep <- which(db$Sex %in% levels_to_keep)
VCV_filtered <- VCV[indices_to_keep, indices_to_keep]
#| label: model_sex
mSX <- rma.mv(yi = lnRR,
V = VCV_filtered,
mods = ~ Sex-1,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db_filtered)
summary(mSX)
r2SX <- round(r2_ml(mSX), 4)
r2SX
#| label: orchard_sex
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_sex<-orchard_plot(mSX,
mod = "Sex",
group = "Study_ID",
xlab = "lnRR",
flip = FALSE) +
scale_colour_brewer(palette = "Dark2") +
scale_fill_brewer(palette = "Set1")+scale_y_continuous(breaks = seq(-5, 10, by = 2),
minor_breaks = seq(-5, 10, by = 1 ))
orchard_sex
mSX <- rma.mv(yi = lnRR,
V = VCV_filtered,
mods = ~ Sex,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db_filtered)
summary(mSX)
#| label: model_music_genre
mMG <- rma.mv(yi = lnRR,
V = VCV,
mods = ~ Meta_genre-1,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db)
summary(mMG)
r2MG <- round(r2_ml(mMG), 4)
r2MG
#| label: orchard_music_genre
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_genre<-orchard_plot(mMG,
mod = "Meta_genre",
group = "Study_ID",
xlab = "lnRR",
flip = FALSE) +
scale_colour_brewer(palette = "Dark2") +
scale_fill_brewer(palette = "Set1")+scale_y_continuous(breaks = seq(-5, 10, by = 2),
minor_breaks = seq(-5, 10, by = 1 ))
orchard_genre
#| label: music_genre_contrasts1
summary(glht(mMG, linfct=cbind(contrMat(rep(1,4), type="Tukey"))), test=adjusted("none"))
#| label: filter_music_exposure
#| fold: TRUE
k_counts <- db %>%
group_by(Music_exposure_duration) %>%
summarise(k_es = n())
levels_to_keep <- k_counts %>%
filter(k_es >= 5) %>%
pull(Music_exposure_duration)
db_filtered <- db %>%
filter(Music_exposure_duration %in% levels_to_keep)
indices_to_keep <- which(db$Music_exposure_duration %in% levels_to_keep)
VCV_filtered <- VCV[indices_to_keep, indices_to_keep]
#| label: model_music_exposure
mMED <- rma.mv(yi = lnRR,
V = VCV_filtered,
mods = ~ Music_exposure_duration-1,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db_filtered)
summary(mMED)
r2MED <- round(r2_ml(mMED), 4)
r2MED
#| label: orchard_music_exposure
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_exposure<-orchard_plot(mMED,
mod = "Music_exposure_duration",
group = "Study_ID",
xlab = "log response ratio (lnRR)",
flip = FALSE)  +
scale_colour_brewer(palette = "Dark2") +
scale_fill_brewer(palette = "Set1")+scale_y_continuous(breaks = seq(-5, 10, by = 2),
minor_breaks = seq(-5, 10, by = 1 ))
orchard_exposure
summary(glht(mMED, linfct=cbind(contrMat(rep(1,3), type="Tukey"))), test=adjusted("none"))
#| label: model_experimental_design
mEXD <- rma.mv(yi = lnRR,
V = VCV,
mods = ~ Experimental_design-1,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db)
summary(mEXD)
r2EXD <- round(r2_ml(mEXD), 4)
r2EXD
#| label: orchard_experimental_design
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_design<-orchard_plot(mEXD,
mod = "Experimental_design",
group = "Study_ID",
xlab = "log response ratio (lnRR)",
flip=FALSE) +scale_y_continuous(breaks = seq(-5, 10, by = 2),
minor_breaks = seq(-5, 10, by = 1 ))
orchard_design
#| label: music_genre_contrasts
summary(glht(mEXD, linfct=cbind(contrMat(rep(1,3), type="Tukey"))), test=adjusted("none"))
#| label: model_induced_behaviour
mIB <- rma.mv(yi = lnRR,
V = VCV,
mods = ~ `Induced behaviour`-1,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db)
summary(mIB)
r2IB <- round(r2_ml(mIB), 4)
r2IB
mIB <- rma.mv(yi = lnRR,
V = VCV,
mods = ~ `Induced behaviour`,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db)
summary(mIB)
#| label: model+_relative_timing
mRT <- rma.mv(yi = lnRR,
V = VCV,
mods = ~ Relative_timing-1,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db)
summary(mRT)
r2RT <- round(r2_ml(mRT), 4)
r2RT
#| label: orchard_relative_timing
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_plot(mRT,
mod = "Relative_timing",
group = "Study_ID",
xlab = "log response ratio (lnRR)",
angle = 30)
summary(glht(mRT, linfct=cbind(contrMat(rep(1,3), type="Tukey"))), test=adjusted("none"))
#| label: model_Experimental_procedures
mEXP <- rma.mv(yi = lnRR,
V = VCV,
mods = ~ Experimental_procedures-1,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db)
summary(mEXP)
r2EXP <- round(r2_ml(mEXP), 4)
r2EXP
#| label: orchard_experimental_procedures
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_plot(mEXP,
mod = "Experimental_procedures",
group = "Study_ID",
xlab = "log response ratio (lnRR)",
angle = 30)
mEXP <- rma.mv(yi = lnRR,
V = VCV,
mods = ~ Experimental_procedures,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db)
summary(mEXP)
# 1. Identify and Filter Low-K Levels
k_counts <- db %>%
group_by(Assay_type) %>%
summarise(k_es = n())
# Identify the levels to keep (where k_es >= 5)
levels_to_keep <- k_counts %>%
filter(k_es >= 5) %>%
pull(Assay_type)
# 2. Create the Filtered Data Frame
db_filtered <- db %>%
filter(Assay_type %in% levels_to_keep)
# 3. Subset the VCV Matrix (CRITICAL STEP)
# Assumes VCV matrix rows/columns match the original 'db' data frame indices.
indices_to_keep <- which(db$Assay_type %in% levels_to_keep)
VCV_filtered <- VCV[indices_to_keep, indices_to_keep]
#| label: model_assay_type
mAT <- rma.mv(yi = lnRR,
V = VCV_filtered,
mods = ~ Assay_type-1,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db_filtered)
summary(mAT)
r2AT <- round(r2_ml(mAT), 4)
r2AT
#| label: orchard_assay_type
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_plot(mAT,
mod = "Assay_type",
group = "Study_ID",
xlab = "log response ratio (lnRR)",
angle = 30)
summary(glht(mAT, linfct=cbind(contrMat(rep(1,3), type="Tukey"))), test=adjusted("none"))
summary(glht(mAT, linfct=cbind(contrMat(rep(1,6), type="Tukey"))), test=adjusted("none"))
