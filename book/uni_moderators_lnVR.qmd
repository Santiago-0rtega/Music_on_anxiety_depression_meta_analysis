---
title: "Uni-moderator (lnVR)"
---

```{r}
#| label: setup
#| include: false
pacman::p_load(
               DT,
               dtplyr,
               here, 
               knitr,
               tidyverse,
               patchwork,
               metafor,
               orchaRd 
               )

#| label: load_and_clean_data
# LOAD THE lnVR DATASET HERE
db <- readr::read_csv(here("..","data","db_lnVR.csv")) %>%
  mutate(across(c(C_n, Ex_n, C_mean, Ex_mean, C_SE, Ex_SE, C_SD, Ex_SD, lnVR, lnVR_var), as.numeric)) %>%
  mutate(across(where(is.character), as.factor)) 


# CALCULATE VCV USING lnVR VARIANCE
VCV <- metafor::vcalc(
  vi = lnVR_var,       
  cluster = Cohort_ID, # The clustering variable (Study_ID + Ex_ID)
  obs = ES_ID,         # The unique observation/effect size ID
  rho = 0.5,           # Assumed correlation between outcomes from the same cohort
  data = db 
)
```

::: panel-tabset

1. The Generator
```{r}

#| label: contrast_function
#| fold: TRUE

contrast_fun <- function(data, response, moderator, VCV){
    
    # --- 1. Setup Dynamic Names ---
    # We grab the actual names of the columns so we can use them in the formulas below
    mod  <- deparse(substitute(moderator))
    resp <- deparse(substitute(response))
    
    # --- 2. Identify Groups ---
    # Find all unique categories in the moderator and ensure it's a factor
    names <- levels(as.factor(data[[mod]]))
    moderator <- as.factor(data[[mod]])
    
    # --- 3. The Model Runner ---
    # This internal function fits the meta-regression repeatedly.
    # It changes the 'ref' (reference level) dynamically each time.
    run_rma <- function(name) {
        rma.mv(yi = data[[resp]], 
               V = VCV, 
               # Here is the magic: we force the model to use 'name' as the baseline
               mods = ~ relevel(moderator, ref = name), 
               random = list(~1|Study_ID, ~1|ES_ID, ~1|Strain), 
               test = "t", 
               data = data, 
               sparse = TRUE)
    }
    
    # --- 4. Loop Through Groups ---
    # We run the model n-1 times (we don't need the last one as it's covered by previous runs).
    # map() iterates through the names and applies run_rma() to each.
    contra <- purrr::map(names[-length(names)], run_rma)
    
    return(contra)
}
```

2. The Harvester
```{r}

#| label: the harvester_function
#| fold: TRUE


get_estimate <- function(model, contra, moderator) {
    
    mod <- deparse(substitute(moderator))
    
    # Utility: Make text look nice (e.g., "control" -> "Control")
    capitalize_first <- function(x) {
        paste0(toupper(substring(x, 1, 1)), substring(x, 2))
    }
    
    # --- Helper A: Get Group Means ---
    # Extracts the estimated mean effect size for each group from the base model
    get_pred1 <- function (model, mod = mod) {
        # Clean up row names to just get the group name
        name_raw <- as.character(stringr::str_replace(row.names(model$beta), mod, ""))
        name <- capitalize_first(name_raw)
        len <- length(name)
        
        # Create a dummy matrix to predict the mean for each group individually
        newdata <- matrix(NA, ncol = len, nrow = len)
        for (i in 1:len) {
            pos <- which(model$X[, i] == 1)[[1]] 
            newdata[i, ] <- model$X[pos, ]       
        }
        
        # Predict values
        pred <- metafor::predict.rma(model, newmods = newdata)
        
        # Format into a tibble
        tibble::tibble(
            name = factor(name, levels = name, labels = name),
            estimate = pred$pred,
            lowerCL = pred$ci.lb, upperCL = pred$ci.ub,
            pval = model$pval, 
            lowerPR = pred$cr.lb, upperPR = pred$cr.ub
        )
    }
    
    # --- Helper B: Get Pairwise Differences ---
    # Extracts the "contrasts" (differences between groups) from the re-leveled models
    get_pred2 <- function (model) {
        name <- row.names(model$beta) 
        len <- length(name)
        newdata <- diag(len)
        
        # 1. Get the Intercept (The Reference Group Mean)
        pred1 <- data.frame(metafor::predict.rma(model, newmods = newdata[1,-1]))
        names(pred1) <- c("pred", "se", "ci.lb", "ci.ub", "cr.lb", "cr.ub") 
        
        # 2. Get the Contrasts (Difference from Reference)
        pred2 <- data.frame(metafor::predict.rma(model, intercept = FALSE, newmods = newdata[-1,-1]))
        names(pred2) <- c("pred", "se", "ci.lb", "ci.ub", "cr.lb", "cr.ub") 

        pred <- rbind(pred1, pred2)
        
        tibble::tibble(
            name = factor(name, levels = name, labels = name),
            estimate = pred$pred,
            lowerCL = pred$ci.lb, upperCL = pred$ci.ub,
            pval = model$pval,
            lowerPR = pred$cr.lb, upperPR = pred$cr.ub
        )
    }
    
    # --- Helper C: Combine Everything ---
    # Stitches the group means and the pairwise differences into one big table
    mr_results <- function(res1, res2) {
    
        # Logic to name the comparisons (e.g., "Treatment-Control") based on order
        get_ordered_contrast_names <- function(level_names) {
            reference_levels <- level_names[-length(level_names)] 
            ordered_names <- c()
            
            for (ref in reference_levels) {
                coefficient_levels <- level_names[level_names != ref]
                # Format: "ComparisonGroup - ReferenceGroup"
                ordered_names <- c(ordered_names, paste(coefficient_levels, ref, sep="-"))
            }
            return(ordered_names)
        }

        level_names <- as.character(res1$name)
        new_contrast_names <- get_ordered_contrast_names(level_names)
        
        tibble::tibble(
            Levels = c(level_names, new_contrast_names),
            Estimate = c(res1$estimate, res2$estimate),
            Lower_CI = c(res1$lowerCL, res2$lowerCL),
            Upper_CI = c(res1$upperCL, res2$upperCL),
            P_value = c(res1$pval, res2$pval),
            Lower_PI = c(res1$lowerPR, res2$lowerPR),
            Upper_PI = c(res1$upperPR, res2$upperPR)
        )
    }
    
    # --- MAIN EXECUTION FLOW ---
    
    # 1. Calculate Group Means (Base Model)
    res1 <- get_pred1(model, mod = mod)
    
    # 2. Calculate Contrasts (Re-leveled Models)
    estimates <- purrr::map(contra, ~ get_pred2(.x))
    
    # 3. Drop intercepts from contrast models (we only want the differences)
    res2 <- purrr::map_dfr(estimates, ~.x[-1, ]) 
    
    # 4. Final Polish
    results <- mr_results(res1, res2)
    
    return(results)
}
```


3. The cleaner
```{r}
#| label: clean_unique_contrasts_function
#| fold: TRUE

clean_unique_contrasts <- function(full_results_table, level_count = 6) {
  
  # --- 1. Split Data ---
  # Keep the single group means safe at the top
  level_estimates <- full_results_table[1:level_count, ]
  # Isolate the pairwise comparisons
  contrast_estimates <- full_results_table[-(1:level_count), ]
  
  # --- 2. Clean Names ---
  # Parse "GroupA-GroupB" into separate columns
  contrast_estimates <- contrast_estimates %>%
    mutate(
      Level1 = str_extract(Levels, "^(.*?)-"),
      Level2 = str_extract(Levels, "-(.*?)$")
    ) %>%
    mutate(
      Level1 = str_replace_all(Level1, "-", ""),
      Level2 = str_replace_all(Level2, "-", "")
    )
  
  # --- 3. Deduplicate ---
  # Create a sorted key so "A_B" and "B_A" are treated as identical
  unique_contrasts <- contrast_estimates %>%
    mutate(
      Unique_Pair_Key = paste(pmin(Level1, Level2), pmax(Level1, Level2), sep = "_")
    ) %>%
    # Keep only the first instance of each unique pair
    distinct(Unique_Pair_Key, .keep_all = TRUE) %>%
    select(-Level1, -Level2, -Unique_Pair_Key)
  
  # --- 4. Recombine ---
  final_table <- bind_rows(level_estimates, unique_contrasts)
  
  return(final_table)
}
```


:::


# Meta-regressions
::: {.callout-note icon="true"}

## Outcome type: Anxiety and Depression

```{r}
#| label: filter_outcome_type
#| fold: TRUE

k_counts <- db %>%
  group_by(Outcome_type) %>%
  summarise(k_es = n())


levels_to_keep <- k_counts %>%
  filter(k_es >= 5) %>%
  pull(Outcome_type)


db_filtered <- db %>%
  filter(Outcome_type %in% levels_to_keep)

indices_to_keep <- which(db$Outcome_type %in% levels_to_keep)
VCV_filtered <- VCV[indices_to_keep, indices_to_keep]
```


```{r}
#| label: model_outcome_type

mOT <- rma.mv(yi = lnVR, 
                  V = VCV_filtered, 
              mods = ~ Outcome_type-1,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID,
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db_filtered)

summary(mOT)
```
```{r}
r2OT <- round(r2_ml(mOT), 4)
r2OT
```
```{r}
#| label: orchard_outcome_type
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_outcome<-orchard_plot(mOT,
              mod = "Outcome_type",
               group = "Study_ID",
               xlab = "log variability ratio (lnVR)", # Changed Label
              flip = FALSE) +
            scale_colour_brewer(palette = "Set1") +
            scale_fill_brewer(palette = "Dark2")+scale_y_continuous(limits = c(-6,11),breaks = seq(-6, 10, by = 2),
                                                                    minor_breaks = seq(-6, 11, by = 1 ))
orchard_outcome
```
```{r}
#| label: save-figure
#| eval: false

ggsave(filename = here("..","Plots", "orchard_outcome_lnVR.pdf"),
       plot = orchard_outcome,
       dpi = 300, device = cairo_pdf)

ggsave(filename = here("..","Plots", "orchard_outcome_lnVR.jpg"), 
       plot = orchard_outcome,
       width = 7,  
       height = 9,  
       dpi = 300)
```
### Contrast between levels (Anxiety as reference level)
```{r}
mOT <- rma.mv(yi = lnVR, # Changed to lnVR
                  V = VCV_filtered, 
              mods = ~ Outcome_type,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID,
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db_filtered)

summary(mOT)
```


## Lifestage of exposure
```{r}
#| label: model_lifestage_exp

mLE <- rma.mv(yi = lnVR, # Changed to lnVR
                  V = VCV, 
              mods = ~ Lifestage_exposure-1,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID,
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db)

summary(mLE)
```


```{r}
r2LE <- round(r2_ml(mLE), 4)
r2LE
```
```{r}
#| label: orchard_lifestage_exp
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_lifestage<-orchard_plot(mLE,
              mod = "Lifestage_exposure",
               group = "Study_ID",
                xlab = "log variability ratio (lnVR)", # Changed Label
              flip = FALSE) +
            scale_colour_brewer(palette = "Set1") +
            scale_fill_brewer(palette = "Dark2")+scale_y_continuous(limits=c(-6,11),breaks = seq(-6, 10, by = 2),
                                                                    minor_breaks = seq(-6, 10, by = 1 ))
orchard_lifestage
```
```{r}
#| label: save-figure_lifestage
#| eval: false

ggsave(filename = here("..","Plots", "orchard_lifestage_lnVR.pdf"), 
       plot = orchard_lifestage,
       dpi = 300, device = cairo_pdf)

ggsave(filename = here("..","Plots", "orchard_lifestage_lnVR.jpg"),
       plot = orchard_lifestage,
       width = 9,  
       height = 7,  
       dpi = 300)
```
### Contrasts between levels
```{r}
#| label: lifestage_contrasts

# Here we apply our custum functions
# The Generator
contra_LE <- contrast_fun(data = db, 
                          response = lnVR, 
                          moderator = Lifestage_exposure, 
                          VCV = VCV)

#The Harvester
t1<-get_estimate(model = mLE, contra = contra_LE, moderator = Lifestage_exposure)

#The Cleaner
t2 <- clean_unique_contrasts(full_results_table = t1, level_count = 6)


t2
```















