---
title: "Uni-moderators"
---

```{r}
#| label: setup
#| include: false
pacman::p_load(
               DT,
               dtplyr,
               here, 
               knitr,
               tidyverse,
               patchwork,
               metafor,
               orchaRd, 
               )

#| label: load_and_clean_data
db <- readr::read_csv(here("..","data","db_lnRR.csv")) %>%
mutate(across(c(C_n, Ex_n, C_mean, Ex_mean, C_SE, Ex_SE, C_SD, Ex_SD), as.numeric))%>%
  mutate(across(where(is.character), as.factor)) 



VCV <- metafor::vcalc(
  vi = lnRR_var,
  cluster = Cohort_ID, # The clustering variable (Study_ID + Ex_ID)
  obs = ES_ID,         # The unique observation/effect size ID
  rho = 0.5,           # Assumed correlation between outcomes from the same cohort
  data = db 
)
```

::: callout-note
Variable definitions:

| Variable Name | Definition |
|:-----------------------------------|:-----------------------------------|
| **`ES_ID`** | Unique row identifier for each $\text{lnRR}$ effect size. |
| **`Study_ID`** | Identifier for the primary research paper. |
| **`Cohort_ID`** | Identifier for specific experimental groups within a study. |
| **`Outcome_type`** | The behavioral construct measured. Levels: **Anxiety**, **Depression**, **both**, **unclear**. |
| **`Lifestage_exposure`** | Animal's developmental stage during music exposure. Levels: **Adolescent**, **Juvenile**, **Young adult**, **Adult**, **Mixed**, **Unclear**. |
| **`Sex`** | Sex of the subjects. Levels: **Male**, **Female**. |
| **`Strain`** | Specific animal strain or species used. |
| **`Meta_genre`** | Categorization of the music stimulus. Levels: **Western Art Music / Orchestral**, **Popular Contemporary Music**, **Traditional Music / Folk / World**, **Mixed**, **Unclear**. |
| **`Music_exposure_duration`** | Total time subjects were exposed to music. Levels: **Acute**, **short**, **medium**, **long**. |
| **`Experimental_design`** | Study's methodological setup. Levels: **Posttest-Only Control Group**, **Randomized Block**, **Factorial**, **Repeated Measures**. |
| **`Induced behaviour`** | Whether the tested behavior was innate or experimentally induced. |
| **`Relative_timing`** | When music was administered relative to the behavioral test. Levels: **before**, **concurrent**, **both**, **not specified**. |
| **`Experimental_procedures`** | Identifies non-treatment controls for interventions. Levels: **sham**, **none**. |
| **`Control_condition`** | Description of the control group condition. Levels: **white noise**, **ambient noise** |
| **`Assay_type`** | Type of behavioral test used. |
| **`Overall_rob`** | Overall risk of bias assessment for each study. Levels: **2 (low)**, **1 (moderate)**, **0 (high)**. |
:::

## Functions for pairwise contrasts

General Explanation This set of functions automates a common but tedious task in meta-analysis: calculating all pairwise comparisons between groups.

-   Function 1 (The Generator): Standard meta-regression usually compares all groups against a single "Reference" group. This function "hacks" that by re-running the model multiple times, rotating the reference group each time so that every group gets a turn as the baseline.

-   Function 2 (The Harvester): This extracts the statistical results (estimates, confidence intervals, p-values) from all those models and organizes them into a single, readable table.

-   Function 3 (The Cleaner): Because the first two steps calculate both "Group A vs B" and "Group B vs A" (which are mathematically identical), this function filters out the duplicates to leave you with a clean, unique list of comparisons.

::: panel-tabset
## 1. The Generator

```{r}
#| label: contrast_function
#| fold: TRUE

contrast_fun <- function(data, response, moderator, VCV){
    
    # --- 1. Setup Dynamic Names ---
    # We grab the actual names of the columns so we can use them in the formulas below
    mod  <- deparse(substitute(moderator))
    resp <- deparse(substitute(response))
    
    # --- 2. Identify Groups ---
    # Find all unique categories in the moderator and ensure it's a factor
    names <- levels(as.factor(data[[mod]]))
    moderator <- as.factor(data[[mod]])
    
    # --- 3. The Model Runner ---
    # This internal function fits the meta-regression repeatedly.
    # It changes the 'ref' (reference level) dynamically each time.
    run_rma <- function(name) {
        rma.mv(yi = data[[resp]], 
               V = VCV, 
               # Here is the magic: we force the model to use 'name' as the baseline
               mods = ~ relevel(moderator, ref = name), 
               random = list(~1|Study_ID, ~1|ES_ID, ~1|Strain), 
               test = "t", 
               data = data, 
               sparse = TRUE)
    }
    
    # --- 4. Loop Through Groups ---
    # We run the model n-1 times (we don't need the last one as it's covered by previous runs).
    # map() iterates through the names and applies run_rma() to each.
    contra <- purrr::map(names[-length(names)], run_rma)
    
    return(contra)
}
```

## 2. The Harvester

```{r}
#| label: the harvester_function
#| fold: TRUE


get_estimate <- function(model, contra, moderator) {
    
    mod <- deparse(substitute(moderator))
    
    # Utility: Make text look nice (e.g., "control" -> "Control")
    capitalize_first <- function(x) {
        paste0(toupper(substring(x, 1, 1)), substring(x, 2))
    }
    
    # --- Helper A: Get Group Means ---
    # Extracts the estimated mean effect size for each group from the base model
    get_pred1 <- function (model, mod = mod) {
        # Clean up row names to just get the group name
        name_raw <- as.character(stringr::str_replace(row.names(model$beta), mod, ""))
        name <- capitalize_first(name_raw)
        len <- length(name)
        
        # Create a dummy matrix to predict the mean for each group individually
        newdata <- matrix(NA, ncol = len, nrow = len)
        for (i in 1:len) {
            pos <- which(model$X[, i] == 1)[[1]] 
            newdata[i, ] <- model$X[pos, ]       
        }
        
        # Predict values
        pred <- metafor::predict.rma(model, newmods = newdata)
        
        # Format into a tibble
        tibble::tibble(
            name = factor(name, levels = name, labels = name),
            estimate = pred$pred,
            lowerCL = pred$ci.lb, upperCL = pred$ci.ub,
            pval = model$pval, 
            lowerPR = pred$cr.lb, upperPR = pred$cr.ub
        )
    }
    
    # --- Helper B: Get Pairwise Differences ---
    # Extracts the "contrasts" (differences between groups) from the re-leveled models
    get_pred2 <- function (model) {
        name <- row.names(model$beta) 
        len <- length(name)
        newdata <- diag(len)
        
        # 1. Get the Intercept (The Reference Group Mean)
        pred1 <- data.frame(metafor::predict.rma(model, newmods = newdata[1,-1]))
        names(pred1) <- c("pred", "se", "ci.lb", "ci.ub", "cr.lb", "cr.ub") 
        
        # 2. Get the Contrasts (Difference from Reference)
        pred2 <- data.frame(metafor::predict.rma(model, intercept = FALSE, newmods = newdata[-1,-1]))
        names(pred2) <- c("pred", "se", "ci.lb", "ci.ub", "cr.lb", "cr.ub") 

        pred <- rbind(pred1, pred2)
        
        tibble::tibble(
            name = factor(name, levels = name, labels = name),
            estimate = pred$pred,
            lowerCL = pred$ci.lb, upperCL = pred$ci.ub,
            pval = model$pval,
            lowerPR = pred$cr.lb, upperPR = pred$cr.ub
        )
    }
    
    # --- Helper C: Combine Everything ---
    # Stitches the group means and the pairwise differences into one big table
    mr_results <- function(res1, res2) {
    
        # Logic to name the comparisons (e.g., "Treatment-Control") based on order
        get_ordered_contrast_names <- function(level_names) {
            reference_levels <- level_names[-length(level_names)] 
            ordered_names <- c()
            
            for (ref in reference_levels) {
                coefficient_levels <- level_names[level_names != ref]
                # Format: "ComparisonGroup - ReferenceGroup"
                ordered_names <- c(ordered_names, paste(coefficient_levels, ref, sep="-"))
            }
            return(ordered_names)
        }

        level_names <- as.character(res1$name)
        new_contrast_names <- get_ordered_contrast_names(level_names)
        
        tibble::tibble(
            Levels = c(level_names, new_contrast_names),
            Estimate = c(res1$estimate, res2$estimate),
            Lower_CI = c(res1$lowerCL, res2$lowerCL),
            Upper_CI = c(res1$upperCL, res2$upperCL),
            P_value = c(res1$pval, res2$pval),
            Lower_PI = c(res1$lowerPR, res2$lowerPR),
            Upper_PI = c(res1$upperPR, res2$upperPR)
        )
    }
    
    # --- MAIN EXECUTION FLOW ---
    
    # 1. Calculate Group Means (Base Model)
    res1 <- get_pred1(model, mod = mod)
    
    # 2. Calculate Contrasts (Re-leveled Models)
    estimates <- purrr::map(contra, ~ get_pred2(.x))
    
    # 3. Drop intercepts from contrast models (we only want the differences)
    res2 <- purrr::map_dfr(estimates, ~.x[-1, ]) 
    
    # 4. Final Polish
    results <- mr_results(res1, res2)
    
    return(results)
}
```

## 3. The cleaner

```{r}
#| label: clean_unique_contrasts_function
#| fold: TRUE

clean_unique_contrasts <- function(full_results_table, level_count = 6) {
  
  # --- 1. Split Data ---
  # Keep the single group means safe at the top
  level_estimates <- full_results_table[1:level_count, ]
  # Isolate the pairwise comparisons
  contrast_estimates <- full_results_table[-(1:level_count), ]
  
  # --- 2. Clean Names ---
  # Parse "GroupA-GroupB" into separate columns
  contrast_estimates <- contrast_estimates %>%
    mutate(
      Level1 = str_extract(Levels, "^(.*?)-"),
      Level2 = str_extract(Levels, "-(.*?)$")
    ) %>%
    mutate(
      Level1 = str_replace_all(Level1, "-", ""),
      Level2 = str_replace_all(Level2, "-", "")
    )
  
  # --- 3. Deduplicate ---
  # Create a sorted key so "A_B" and "B_A" are treated as identical
  unique_contrasts <- contrast_estimates %>%
    mutate(
      Unique_Pair_Key = paste(pmin(Level1, Level2), pmax(Level1, Level2), sep = "_")
    ) %>%
    # Keep only the first instance of each unique pair
    distinct(Unique_Pair_Key, .keep_all = TRUE) %>%
    select(-Level1, -Level2, -Unique_Pair_Key)
  
  # --- 4. Recombine ---
  final_table <- bind_rows(level_estimates, unique_contrasts)
  
  return(final_table)
}
```
:::

## Meta-regressions




::: {.callout-note icon="true"}
## Data Filtering & Matrix Alignment

This snippet performs quality control before running your meta-analysis. It serves two critical functions:

Ensures Reliability: It removes specific levels of your moderator (groups) that have too little data to be trusted (in this case, fewer than 5 effect sizes).

Prevents Errors: Crucially, it subsets the Variance-Covariance (VCV) matrix to match your filtered data. Since the VCV matrix is a square grid where every row/column corresponds to a row in your data, filtering the data without "cropping" the matrix correspondingly will cause your model to crash due to a dimension mismatch.

```{r}
#| label: filter_low_k
#| eval: FALSE

# 1. Identify and Filter Low-K Levels
# (Replace 'Outcome_type' with the specific moderator column name)

# Calculate the count of ES_ID (k) for each level of the moderator
k_counts <- db %>%
  group_by(Outcome_type) %>%
  summarise(k_es = n())

# Identify the levels to keep (where k_es >= 5)
levels_to_keep <- k_counts %>%
  filter(k_es >= 5) %>%
  pull(Outcome_type)

# 2. Create the Filtered Data Frame
db_filtered <- db %>%
  filter(Outcome_type %in% levels_to_keep)

# 3. Subset the VCV Matrix (CRITICAL STEP)
# Assumes VCV matrix rows/columns match the original 'db' data frame indices.
indices_to_keep <- which(db$Outcome_type %in% levels_to_keep)
VCV_filtered <- VCV[indices_to_keep, indices_to_keep]
```

:::



::: {.callout-tip}

Manual Reference Rotation for SubsetsThe automated contrast functions are designed for full datasets. When you filter for data availability (e.g., keeping only levels with $k \ge 5$) and are left with more than 2 levels, it is often safer to manually "rotate" the reference level.
How it works:In meta-regression with an intercept, the Intercept represents the mean of the Reference Level. 
The other coefficients represent the difference between the reference and the other groups.By manually changing the reference (ref = ...) and re-running the model for each level, you mathematically force the model to calculate every possible pairwise comparison (e.g., A vs B, B vs C, A vs C) and their specific p-values.

- 2 Levels remaining? You only need one model (Intercept = Group A, Coefficient = Difference).
- 3+ Levels remaining? Use the rotation method below.

```{r}
#| label: manual_contrasts
#| eval: FALSE

# 0. Define your levels of interest
LEVELS <- c("Acute", "Medium", "Short")
# (Optional) Store moderator name for clarity
MOD_NAME <- "Music_exposure_duration"

# --- Model A: Reference = Acute ---
# Intercept = Acute Mean
# Coefficients = (Medium - Acute) and (Short - Acute)
db_filtered$moderator_relevel_A <- relevel(db_filtered$Music_exposure_duration, ref = LEVELS[1])
model_A <- rma.mv(yi = lnRR,
                  V = VCV_filtered, 
                  mods = ~ moderator_relevel_A,
                  random = list(~1 | Study_ID, ~1 | ES_ID, ~1 | Strain),
                  test = "t", method = "REML", sparse = TRUE,
                  data = db_filtered)
model_A

# --- Model B: Reference = Medium ---
# Intercept = Medium Mean
# Coefficients = (Acute - Medium) and (Short - Medium)
# *Key Gain: This gives us the specific P-value for Short vs Medium*
db_filtered$moderator_relevel_B <- relevel(db_filtered$Music_exposure_duration, ref = LEVELS[2])
model_B <- rma.mv(yi = lnRR,
                  V = VCV_filtered, 
                  mods = ~ moderator_relevel_B,
                  random = list(~1 | Study_ID, ~1 | ES_ID, ~1 | Strain),
                  test = "t", method = "REML", sparse = TRUE,
                  data = db_filtered)
model_B

# --- Model C: Reference = Short ---
# Intercept = Short Mean
# Coefficients = (Acute - Short) and (Medium - Short)
# *Useful for: Getting the direct estimate/CI for the "Short" group mean*
db_filtered$moderator_relevel_C <- relevel(db_filtered$Music_exposure_duration, ref = LEVELS[3])
model_C <- rma.mv(yi = lnRR,
                  V = VCV_filtered, 
                  mods = ~ moderator_relevel_C,
                  random = list(~1 | Study_ID, ~1 | ES_ID, ~1 | Strain),
                  test = "t", method = "REML", sparse = TRUE,
                  data = db_filtered)
model_C
```

:::




:::: panel-tabset
## 1. Outcome type: Anxiety and Depression
```{r}
#| label: filter_outcome_type
#| fold: TRUE

k_counts <- db %>%
  group_by(Outcome_type) %>%
  summarise(k_es = n())


levels_to_keep <- k_counts %>%
  filter(k_es >= 5) %>%
  pull(Outcome_type)


db_filtered <- db %>%
  filter(Outcome_type %in% levels_to_keep)

indices_to_keep <- which(db$Outcome_type %in% levels_to_keep)
VCV_filtered <- VCV[indices_to_keep, indices_to_keep]
```

```{r}
#| label: model_outcome_type

mOT <- rma.mv(yi = lnRR,
                  V = VCV_filtered, 
              mods = ~ Outcome_type-1,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID,
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db_filtered)

summary(mOT)

```

```{r}
r2OT <- round(r2_ml(mOT), 4)
r2OT
```

```{r}
#| label: orchard_outcome_type
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_outcome<-orchard_plot(mOT,
             mod = "Outcome_type",
              group = "Study_ID",
              xlab = "lnRR", 
             flip = FALSE) +
            scale_colour_brewer(palette = "Set1") +
            scale_fill_brewer(palette = "Dark2")+scale_y_continuous(breaks = seq(-8, 10, by = 2),
                                                                    minor_breaks = seq(-8, 10, by = 1 ))
orchard_outcome
```
```{r}
#| label: save-figure
#| eval: false

ggsave(filename = here("..","Plots", "orchard_outcome_lnRR.pdf"),
       plot = orchard_outcome,
       dpi = 300, device = cairo_pdf)

ggsave(filename = here("..","Plots", "orchard_outcome_lnRR.jpg"),
       plot = orchard_outcome,
       width = 7,  
       height = 9,  
       dpi = 300)

```
Contrast between levels (Anxiety as reference level)
```{r}
mOT <- rma.mv(yi = lnRR,
                  V = VCV_filtered, 
              mods = ~ Outcome_type,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID,
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db_filtered)

summary(mOT)
```

## 2. Lifestage of exposure

```{r}
#| label: model_lifestage_exp

mLE <- rma.mv(yi = lnRR,
                  V = VCV, 
              mods = ~ Lifestage_exposure-1,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID,
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db)

summary(mLE)

```

```{r}
r2LE <- round(r2_ml(mLE), 4)
r2LE
```



```{r}
#| label: orchard_lifestage_exp
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_lifestage<-orchard_plot(mLE,
             mod = "Lifestage_exposure",
              group = "Study_ID",
               xlab = "lnRR", 
             flip = FALSE) +
            scale_colour_brewer(palette = "Set1") +
            scale_fill_brewer(palette = "Dark2")+scale_y_continuous(breaks = seq(-8, 10, by = 2),
                                                                    minor_breaks = seq(-8, 10, by = 1 ))
orchard_lifestage
```
```{r}
#| label: save-figure_lifestage
#| eval: false

ggsave(filename = here("..","Plots", "orchard_lifestage_lnRR.pdf"),
       plot = orchard_lifestage,
       dpi = 300, device = cairo_pdf)

ggsave(filename = here("..","Plots", "orchard_lifestage_lnRR.jpg"),
       plot = orchard_lifestage,
       width = 9,  
       height = 7,  
       dpi = 300)

```
Contrasts between levels (Adolescent as reference level)
```{r}
#| label: lifestage_contrasts

# Here we apply our custum functions
# The Generator
contra_LE <- contrast_fun(data = db, 
                          response = lnRR, 
                          moderator = Lifestage_exposure, 
                          VCV = VCV)

#The Harvester
t1<-get_estimate(model = mLE, contra = contra_LE, moderator = Lifestage_exposure)

#The Cleaner
t2 <- clean_unique_contrasts(full_results_table = t1, level_count = 6)


t2
```


## 3. Sex

```{r}
#| label: filter_sex
#| fold: TRUE
k_counts <- db %>%
  group_by(Sex) %>%
  summarise(k_es = n())

levels_to_keep <- k_counts %>%
  filter(k_es >= 5) %>%
  pull(Sex)

db_filtered <- db %>%
  filter(Sex %in% levels_to_keep)


indices_to_keep <- which(db$Sex %in% levels_to_keep)
VCV_filtered <- VCV[indices_to_keep, indices_to_keep]
```

```{r}
#| label: model_sex

mSX <- rma.mv(yi = lnRR,
                  V = VCV_filtered, 
              mods = ~ Sex-1,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID,
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db_filtered)

summary(mSX)

```

```{r}
r2SX <- round(r2_ml(mSX), 4)
r2SX
```

```{r}
#| label: orchard_sex
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_sex<-orchard_plot(mSX,
             mod = "Sex",
              group = "Study_ID",
             xlab = "lnRR", 
             flip = FALSE) +
            scale_colour_brewer(palette = "Dark2") +
            scale_fill_brewer(palette = "Set1")+scale_y_continuous(breaks = seq(-5, 10, by = 2),
                                                                    minor_breaks = seq(-5, 10, by = 1 ))
orchard_sex
```
```{r}
#| label: save-figure_sex
#| eval: false

ggsave(filename = here("..","Plots", "orchard_sex_lnRR.pdf"),
       plot = orchard_sex,
       dpi = 300, device = cairo_pdf)

ggsave(filename = here("..","Plots", "orchard_sex_lnRR.jpg"),
       plot = orchard_sex,
       width = 7,  
       height = 9,  
       dpi = 300)

```

Contrast between levels (Female as reference level)
```{r}
mSX <- rma.mv(yi = lnRR,
                  V = VCV_filtered, 
              mods = ~ Sex,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID,
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db_filtered)

summary(mSX)
```

## 4. Music genre

Meta_genre

```{r}
#| label: model_music_genre

mMG <- rma.mv(yi = lnRR,
                  V = VCV, 
              mods = ~ Meta_genre-1,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID,
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db)

summary(mMG)

```

```{r}
r2MG <- round(r2_ml(mMG), 4)
r2MG
```
```{r}
#| label: orchard_music_genre
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_genre<-orchard_plot(mMG,
             mod = "Meta_genre",
              group = "Study_ID",
             xlab = "lnRR", 
             flip = FALSE) +
            scale_colour_brewer(palette = "Dark2") +
            scale_fill_brewer(palette = "Set1")+scale_y_continuous(breaks = seq(-5, 10, by = 2),
                                                                    minor_breaks = seq(-5, 10, by = 1 ))
orchard_genre
```
```{r}
#| label: save-figure_genre
#| eval: false

ggsave(filename = here("..","Plots", "orchard_genre_lnRR.pdf"),
       plot = orchard_genre,
       dpi = 300, device = cairo_pdf)

ggsave(filename = here("..","Plots", "orchard_genre_lnRR.jpg"),
       plot = orchard_genre,
       width = 9,  
       height = 7,  
       dpi = 300)

```


Contrasts between levels 
```{r}
#| label: music_genre_contrasts

# The Generator
contra_mMG <- contrast_fun(data = db, 
                          response = lnRR, 
                          moderator = Meta_genre, 
                          VCV = VCV)
# The Harvester
t1<-get_estimate(model = mMG, contra = contra_mMG, moderator = Meta_genre)
# The Cleaner
t2 <- clean_unique_contrasts(full_results_table = t1, level_count = 4)


t2
```





## 5. Music exposure duration

Music_exposure_duration

```{r}
#| label: filter_music_exposure
#| fold: TRUE

k_counts <- db %>%
  group_by(Music_exposure_duration) %>%
  summarise(k_es = n())

levels_to_keep <- k_counts %>%
  filter(k_es >= 5) %>%
  pull(Music_exposure_duration)

db_filtered <- db %>%
  filter(Music_exposure_duration %in% levels_to_keep)

indices_to_keep <- which(db$Music_exposure_duration %in% levels_to_keep)
VCV_filtered <- VCV[indices_to_keep, indices_to_keep]
```

```{r}
#| label: model_music_exposure

mMED <- rma.mv(yi = lnRR,
                  V = VCV_filtered, 
              mods = ~ Music_exposure_duration-1,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID, 
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db_filtered)

summary(mMED)

```

```{r}
r2MED <- round(r2_ml(mMED), 4)
r2MED
```
```{r}
#| label: orchard_music_exposure
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_exposure<-orchard_plot(mMED,
             mod = "Music_exposure_duration",
              group = "Study_ID",
              xlab = "log response ratio (lnRR)", 
              flip = FALSE)  +
            scale_colour_brewer(palette = "Dark2") +
            scale_fill_brewer(palette = "Set1")+scale_y_continuous(breaks = seq(-5, 10, by = 2),
                                                                   minor_breaks = seq(-5, 10, by = 1 ))
orchard_exposure
```

```{r}
#| label: save-figure_exposure
#| eval: false

ggsave(filename = here("..","Plots", "orchard_exposure_lnRR.pdf"),
       plot = orchard_exposure,
       dpi = 300, device = cairo_pdf)

ggsave(filename = here("..","Plots", "orchard_exposure_lnRR.jpg"),
       plot = orchard_exposure,
       width = 9,  
       height = 7,  
       dpi = 300)

```




Contrasts between levels
```{r}
LEVELS <- c("Acute", "Medium", "Short")
MOD_NAME <- "Music_exposure_duration"
```

```{r}
# Model A: Reference = Acute (A vs B, A vs C)
db_filtered$moderator_relevel_A <- relevel(db_filtered$Music_exposure_duration, ref = LEVELS[1])
model_A <- rma.mv(yi = lnRR,
                  V = VCV_filtered, 
                  mods = ~ moderator_relevel_A,
                  random = list(~1 | Study_ID, ~1 | ES_ID, ~1 | Strain),
                  test = "t", method = "REML", sparse = TRUE,
                  data = db_filtered)
model_A
```

```{r}
# Model B: Reference = Medium (B vs C)
db_filtered$moderator_relevel_B <- relevel(db_filtered$Music_exposure_duration, ref = LEVELS[2])
model_B <- rma.mv(yi = lnRR,
                  V = VCV_filtered, 
                  mods = ~ moderator_relevel_B,
                  random = list(~1 | Study_ID, ~1 | ES_ID, ~1 | Strain),
                  test = "t", method = "REML", sparse = TRUE,
                  data = db_filtered)
model_B
```

```{r}
# Model C: Reference = Short (C estimate)
db_filtered$moderator_relevel_C <- relevel(db_filtered$Music_exposure_duration, ref = LEVELS[3])
model_C <- rma.mv(yi = lnRR,
                  V = VCV_filtered, 
                  mods = ~ moderator_relevel_C,
                  random = list(~1 | Study_ID, ~1 | ES_ID, ~1 | Strain),
                  test = "t", method = "REML", sparse = TRUE,
                  data = db_filtered)
model_C
```





## 6. Experimental design

```{r}
#| label: model_experimental_design

mEXD <- rma.mv(yi = lnRR,
                  V = VCV, 
              mods = ~ Experimental_design-1,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID, 
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db)

summary(mEXD)

```

```{r}
r2EXD <- round(r2_ml(mEXD), 4)
r2EXD
```

```{r}
#| label: orchard_experimental_design
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_design<-orchard_plot(mEXD,
             mod = "Experimental_design",
              group = "Study_ID",
              xlab = "log response ratio (lnRR)", 
              flip=FALSE) +scale_y_continuous(breaks = seq(-5, 10, by = 2),
                                                                  minor_breaks = seq(-5, 10, by = 1 ))
orchard_design
```



```{r}
#| label: save-figure_design
#| eval: false

ggsave(filename = here("..","Plots", "orchard_design_lnRR.pdf"),
       plot = orchard_design,
       dpi = 300, device = cairo_pdf)

ggsave(filename = here("..","Plots", "orchard_design_lnRR.jpg"),
       plot = orchard_design,
       width = 9,  
       height = 7,  
       dpi = 300)

```






Contrasts between levels 
```{r}
#| label: music_genre_contrasts

# The Generator
contra_mEXD <- contrast_fun(data = db, 
                          response = lnRR, 
                          moderator = Experimental_design, 
                          VCV = VCV)
# The Harvester
t1<-get_estimate(model = mEXD, contra = contra_mEXD, moderator = Experimental_design)
# The Cleaner
t2 <- clean_unique_contrasts(full_results_table = t1, level_count = 3)


t2
```



## 7. Induced behaviour

```{r}
#| label: model_induced_behaviour

mIB <- rma.mv(yi = lnRR,
                  V = VCV, 
              mods = ~ `Induced behaviour`-1,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID, 
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db)

summary(mIB)

```

```{r}
r2IB <- round(r2_ml(mIB), 4)
r2IB
```

```{r}
#| label: orchard_INDUCED_BEHAVIOUR
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_behaviour<-orchard_plot(mIB,
             mod = "Induced behaviour",
              group = "Study_ID",
              xlab = "log response ratio (lnRR)", 
              flip = FALSE) +scale_y_continuous(breaks = seq(-5, 10, by = 2),
                                                                 minor_breaks = seq(-5, 10, by = 1 ))
orchard_behaviour
```



```{r}
#| label: save-figure_behaviour
#| eval: false

ggsave(filename = here("..","Plots", "orchard_behaviour_lnRR.pdf"),
       plot = orchard_behaviour,
       dpi = 300, device = cairo_pdf)

ggsave(filename = here("..","Plots", "orchard_behaviour_lnRR.jpg"),
       plot = orchard_behaviour,
       width = 9,  
       height = 7,  
       dpi = 300)

```



```{r}
mIB <- rma.mv(yi = lnRR,
                  V = VCV, 
              mods = ~ `Induced behaviour`,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID, 
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db)

summary(mIB)
```

## 8. Relative timing

```{r}
#| label: model+_relative_timing

mRT <- rma.mv(yi = lnRR,
                  V = VCV, 
              mods = ~ Relative_timing-1,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID, 
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db)

summary(mRT)

```

```{r}
r2RT <- round(r2_ml(mRT), 4)
r2RT
```

```{r}
#| label: orchard_relative_timing
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_plot(mRT,
             mod = "Relative_timing",
              group = "Study_ID",
              xlab = "log response ratio (lnRR)", 
              angle = 30) 
```

```{r}
mRT <- rma.mv(yi = lnRR,
                  V = VCV, 
              mods = ~ Relative_timing,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID, 
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db)

summary(mRT)
```

## 9. Experimental procedures

```{r}
#| label: model_Experimental_procedures

mEXP <- rma.mv(yi = lnRR,
                  V = VCV, 
              mods = ~ Experimental_procedures-1,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID, 
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db)

summary(mEXP)

```

```{r}
r2EXP <- round(r2_ml(mEXP), 4)
r2EXP
```

```{r}
#| label: orchard_experimental_procedures
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_plot(mEXP,
             mod = "Experimental_procedures",
              group = "Study_ID",
              xlab = "log response ratio (lnRR)", 
              angle = 30) 
```

```{r}
mEXP <- rma.mv(yi = lnRR,
                  V = VCV, 
              mods = ~ Experimental_procedures,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID, 
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db)

summary(mEXP)
```

## 10. Control condition

```{r}
#| label: model_control_condition

mCC <- rma.mv(yi = lnRR,
                  V = VCV, 
              mods = ~ Control_conditions-1,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID, 
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db)

summary(mCC)

```

```{r}
r2CC <- round(r2_ml(mCC), 4)
r2CC
```

```{r}
#| label: orchard_control_condition
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_plot(mCC,
             mod = "Control_conditions",
              group = "Study_ID",
              xlab = "log response ratio (lnRR)", 
              angle = 30) 
```

```{r}
mCC <- rma.mv(yi = lnRR,
                  V = VCV, 
              mods = ~ Control_conditions,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID, 
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db)

summary(mCC)
```

## 11. Assay type

```{r}
# 1. Identify and Filter Low-K Levels


k_counts <- db %>%
  group_by(Assay_type) %>%
  summarise(k_es = n())

# Identify the levels to keep (where k_es >= 5)
levels_to_keep <- k_counts %>%
  filter(k_es >= 5) %>%
  pull(Assay_type)

# 2. Create the Filtered Data Frame
db_filtered <- db %>%
  filter(Assay_type %in% levels_to_keep)

# 3. Subset the VCV Matrix (CRITICAL STEP)
# Assumes VCV matrix rows/columns match the original 'db' data frame indices.
indices_to_keep <- which(db$Assay_type %in% levels_to_keep)
VCV_filtered <- VCV[indices_to_keep, indices_to_keep]
```

```{r}
#| label: model_assay_type

mAT <- rma.mv(yi = lnRR,
                  V = VCV_filtered, 
              mods = ~ Assay_type-1,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID, 
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db_filtered)

summary(mAT)

```

```{r}
r2AT <- round(r2_ml(mAT), 4)
r2AT
```

```{r}
#| label: orchard_assay_type
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_plot(mAT,
             mod = "Assay_type",
              group = "Study_ID",
              xlab = "log response ratio (lnRR)", 
              angle = 30) 
```

```{r}
mAT <- rma.mv(yi = lnRR,
                  V = VCV_filtered, 
              mods = ~ Assay_type,
                  random = list(~1 | Study_ID,
                                ~1 | ES_ID, 
                                ~1 | Strain),
                  test = "t",
                  method = "REML", 
                  sparse = TRUE,
                  data = db_filtered)

summary(mAT)
```
::::
