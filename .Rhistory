dtplyr,
here,
knitr,
tidyverse,
patchwork,
metafor,
orchaRd
)
#| label: load_and_clean_data
db <- readr::read_csv(here("data","db_effect_sizes.csv")) %>%
mutate(across(c(C_n, Ex_n, C_mean, Ex_mean, C_SE, Ex_SE, C_SD, Ex_SD), as.numeric))%>%
mutate(across(where(is.character), as.factor))
VCV <- metafor::vcalc(
vi = lnRR_var,
cluster = Cohort_ID, # The clustering variable (Study_ID + Ex_ID)
obs = ES_ID,         # The unique observation/effect size ID
rho = 0.5,           # Assumed correlation between outcomes from the same cohort
data = db
)
#| label: multilevel_meta_analysis
ma_all <- rma.mv(yi = lnRR,
V = VCV,
random = list(~1 | Study_ID,
~1 | Cohort_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db)
summary(ma_all)
#| label: i2_extraction
orchaRd::i2_ml(ma_all)
#| label: r2_extraction
r2 <- round(r2_ml(ma_all), 4)
r2
#| label: refit_model
ma_all <- rma.mv(yi = lnRR,
V = VCV,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db)
summary(ma_all)
#| label: i2_extraction2
orchaRd::i2_ml(ma_all)
#| label: orchard_plot
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_plot(ma_all,
group = "Study_ID",
xlab = "log response ratio (lnRR)",
angle = 45) +
scale_x_discrete(labels = c("Overall effect"))
#| label: setup
#| include: false
pacman::p_load(
DT,
dtplyr,
here,
knitr,
tidyverse,
patchwork,
metafor,
orchaRd, emmeans
)
#| label: load_and_clean_data
db <- readr::read_csv(here("data","db_effect_sizes.csv")) %>%
mutate(across(c(C_n, Ex_n, C_mean, Ex_mean, C_SE, Ex_SE, C_SD, Ex_SD), as.numeric))%>%
mutate(across(where(is.character), as.factor))
VCV <- metafor::vcalc(
vi = lnRR_var,
cluster = Cohort_ID, # The clustering variable (Study_ID + Ex_ID)
obs = ES_ID,         # The unique observation/effect size ID
rho = 0.5,           # Assumed correlation between outcomes from the same cohort
data = db
)
# 1. Identify and Filter Low-K Levels
# Calculate the count of ES_ID (k) for each level of Outcome_type
k_counts <- db %>%
group_by(Outcome_type) %>%
summarise(k_es = n())
# Identify the levels to keep (where k_es >= 5)
levels_to_keep <- k_counts %>%
filter(k_es >= 5) %>%
pull(Outcome_type)
# 2. Create the Filtered Data Frame
db_filtered <- db %>%
filter(Outcome_type %in% levels_to_keep)
# 3. Subset the VCV Matrix (CRITICAL STEP)
# Assumes VCV matrix rows/columns match the original 'db' data frame indices.
indices_to_keep <- which(db$Outcome_type %in% levels_to_keep)
VCV_filtered <- VCV[indices_to_keep, indices_to_keep]
#| label: model_outcome_type
mOT <- rma.mv(yi = lnRR,
V = VCV_filtered,
mods = ~ Outcome_type-1,
random = list(~1 | Study_ID,
~1 | ES_ID),
test = "t",
method = "REML",
sparse = TRUE,
data = db_filtered)
summary(mOT)
r2OT <- round(r2_ml(mOT), 4)
r2OT
#| label: orchard_outcome_type
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_plot(mOT,
mod = "Outcome_type",
group = "Study_ID",
xlab = "log response ratio (lnRR)",
angle = 45)
# 1. Contrast Function (Run one model only)
# Takes: 1) data frame, 2) moderator column name (quoted), and 3) VCV matrix
contrast_fun <- function(data, moderator_name, VCV){
# Ensure the moderator is treated as a factor
data[[moderator_name]] <- as.factor(data[[moderator_name]])
# Define the formula (Include an intercept for easy contrast estimation later)
formula <- as.formula(paste("yi ~", moderator_name))
# Run the baseline meta-regression model (e.g., Acute is the reference)
model <- rma.mv(formula,
V = VCV,
random = list(~1|Study_ID, ~1|ES_ID), # Dropped Strain
test = "t",
data = data,
sparse = TRUE)
return(model)
}
# 2. Function to Get Estimates and Contrasts from ONE model
get_estimate <- function(model, moderator_name) {
# Get names of all levels (in the order R uses for coefficients)
full_names <- levels(as.factor(model$data[[moderator_name]]))
N <- length(full_names)
# --- 1. Get Subgroup Means (The full predicted mean for each level) ---
# Identity matrix for L: 1 at the intercept, 1 at the specific level
L_means <- diag(N) # N x N identity matrix
L_means[, 1] <- 1 # Set Intercept to 1 for all rows (essential for an intercept model)
# The first row is the reference level mean; others are reference + difference
# This tests the absolute mean of each subgroup against zero.
means_preds <- predict(model, newmods = L_means)
# Create results table for means
results_means <- tibble(
Levels = full_names,
Estimate = means_preds$pred,
Lower_CI = means_preds$ci.lb,
Upper_CI = means_preds$ci.ub,
Lower_PI = means_preds$cr.lb,
Upper_PI = means_preds$cr.ub,
Type = "Mean"
)
# --- 2. Get Pairwise Contrasts ---
# Create all unique combinations of levels
combinations <- t(combn(1:N, 2))
# Initialize the L matrix for contrasts
L_contrasts <- matrix(0, nrow = nrow(combinations), ncol = N)
# Fill the L matrix based on the combination indices
# Example: Contrast (2, 4) -> L[i, 2] = 1, L[i, 4] = -1
for (i in 1:nrow(combinations)) {
L_contrasts[i, combinations[i, 1]] <- 1
L_contrasts[i, combinations[i, 2]] <- -1
}
# Test the contrasts using the L matrix and apply Bonferroni correction
contrasts_results <- anova(model, L = L_contrasts, adjust = "bonferroni")
# Create results table for contrasts
results_contrasts <- tibble(
Levels = paste(full_names[combinations[, 1]], full_names[combinations[, 2]], sep = " - "),
Estimate = contrasts_results$beta,
Lower_CI = contrasts_results$ci.lb,
Upper_CI = contrasts_results$ci.ub,
P_value = contrasts_results$pval,
Type = "Contrast"
)
# --- 3. Combine and Return ---
# We need the p-value for the means, which is already in the summary:
pvals_means <- summary(model)$pval[1:N]
results_means <- results_means %>% mutate(P_value = pvals_means)
return(bind_rows(results_means, results_contrasts))
}
# 1. Identify and Filter Low-K Levels
# Calculate the count of ES_ID (k) for each level of Outcome_type
k_counts <- db %>%
group_by(Outcome_type) %>%
summarise(k_es = n())
# Identify the levels to keep (where k_es >= 5)
levels_to_keep <- k_counts %>%
filter(k_es >= 5) %>%
pull(Outcome_type)
# 2. Create the Filtered Data Frame
db_filtered <- db %>%
filter(Outcome_type %in% levels_to_keep)
# 3. Subset the VCV Matrix (CRITICAL STEP)
# Assumes VCV matrix rows/columns match the original 'db' data frame indices.
indices_to_keep <- which(db$Outcome_type %in% levels_to_keep)
VCV_filtered <- VCV[indices_to_keep, indices_to_keep]
#| label: model_outcome_type
mOT <- rma.mv(yi = lnRR,
V = VCV_filtered,
mods = ~ Outcome_type-1,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db_filtered)
summary(mOT)
r2OT <- round(r2_ml(mOT), 4)
r2OT
#| label: orchard_outcome_type
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_plot(mOT,
mod = "Outcome_type",
group = "Study_ID",
xlab = "log response ratio (lnRR)",
angle = 45)
m1C<-contrast_fun(dat=db_filtered,moderator_name = "Outcome_type")
# 1. Contrast Function (Run one model only)
# Takes: 1) data frame, 2) moderator column name (quoted), and 3) VCV matrix
contrast_fun <- function(data, moderator_name, VCV){
# Ensure the moderator is treated as a factor
data[[moderator_name]] <- as.factor(data[[moderator_name]])
# Define the formula (Include an intercept for easy contrast estimation later)
formula <- as.formula(paste("yi ~", moderator_name))
# Run the baseline meta-regression model (e.g., Acute is the reference)
model <- rma.mv(formula,
V = VCV,
random = list(~1|Study_ID, ~1|ES_ID, ~1| Strain),
test = "t",
data = data,
sparse = TRUE)
return(model)
}
VCV <- VCV[indices_to_keep, indices_to_keep]
# 1. Identify and Filter Low-K Levels
# Calculate the count of ES_ID (k) for each level of Outcome_type
k_counts <- db %>%
group_by(Outcome_type) %>%
summarise(k_es = n())
# Identify the levels to keep (where k_es >= 5)
levels_to_keep <- k_counts %>%
filter(k_es >= 5) %>%
pull(Outcome_type)
# 2. Create the Filtered Data Frame
db_filtered <- db %>%
filter(Outcome_type %in% levels_to_keep)
# 3. Subset the VCV Matrix (CRITICAL STEP)
# Assumes VCV matrix rows/columns match the original 'db' data frame indices.
indices_to_keep <- which(db$Outcome_type %in% levels_to_keep)
VCV <- VCV[indices_to_keep, indices_to_keep]
VCV <- metafor::vcalc(
vi = lnRR_var,
cluster = Cohort_ID, # The clustering variable (Study_ID + Ex_ID)
obs = ES_ID,         # The unique observation/effect size ID
rho = 0.5,           # Assumed correlation between outcomes from the same cohort
data = db
)
# 1. Identify and Filter Low-K Levels
# Calculate the count of ES_ID (k) for each level of Outcome_type
k_counts <- db %>%
group_by(Outcome_type) %>%
summarise(k_es = n())
# Identify the levels to keep (where k_es >= 5)
levels_to_keep <- k_counts %>%
filter(k_es >= 5) %>%
pull(Outcome_type)
# 2. Create the Filtered Data Frame
db_filtered <- db %>%
filter(Outcome_type %in% levels_to_keep)
# 3. Subset the VCV Matrix (CRITICAL STEP)
# Assumes VCV matrix rows/columns match the original 'db' data frame indices.
indices_to_keep <- which(db$Outcome_type %in% levels_to_keep)
VCV <- VCV[indices_to_keep, indices_to_keep]
#| label: model_outcome_type
mOT <- rma.mv(yi = lnRR,
V = VCV_filtered,
mods = ~ Outcome_type-1,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db_filtered)
summary(mOT)
#| label: model_outcome_type
mOT <- rma.mv(yi = lnRR,
V = VCV,
mods = ~ Outcome_type-1,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db_filtered)
summary(mOT)
r2OT <- round(r2_ml(mOT), 4)
r2OT
#| label: orchard_outcome_type
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_plot(mOT,
mod = "Outcome_type",
group = "Study_ID",
xlab = "log response ratio (lnRR)",
angle = 45)
m1C<-contrast_fun(dat=db_filtered,moderator_name = "Outcome_type")
# 1. Contrast Function (Run one model only)
# Takes: 1) data frame, 2) moderator column name (quoted), and 3) VCV matrix
contrast_fun <- function(data, moderator_name, VCV){
# Ensure the moderator is treated as a factor
data[[moderator_name]] <- as.factor(data[[moderator_name]])
# Define the formula (Include an intercept for easy contrast estimation later)
formula <- as.formula(paste("yi ~", moderator_name))
# Run the baseline meta-regression model (e.g., Acute is the reference)
model <- rma.mv(formula,
V = V_matrix,
random = list(~1|Study_ID, ~1|ES_ID, ~1| Strain),
test = "t",
data = data,
sparse = TRUE)
return(model)
}
VCV <- metafor::vcalc(
vi = lnRR_var,
cluster = Cohort_ID, # The clustering variable (Study_ID + Ex_ID)
obs = ES_ID,         # The unique observation/effect size ID
rho = 0.5,           # Assumed correlation between outcomes from the same cohort
data = db
)
# 1. Identify and Filter Low-K Levels
# Calculate the count of ES_ID (k) for each level of Outcome_type
k_counts <- db %>%
group_by(Outcome_type) %>%
summarise(k_es = n())
# Identify the levels to keep (where k_es >= 5)
levels_to_keep <- k_counts %>%
filter(k_es >= 5) %>%
pull(Outcome_type)
# 2. Create the Filtered Data Frame
db_filtered <- db %>%
filter(Outcome_type %in% levels_to_keep)
# 3. Subset the VCV Matrix (CRITICAL STEP)
# Assumes VCV matrix rows/columns match the original 'db' data frame indices.
indices_to_keep <- which(db$Outcome_type %in% levels_to_keep)
VCV_filtered <- VCV[indices_to_keep, indices_to_keep]
#| label: model_outcome_type
mOT <- rma.mv(yi = lnRR,
V = VCV,
mods = ~ Outcome_type-1,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db_filtered)
#| label: model_outcome_type
mOT <- rma.mv(yi = lnRR,
V = VCV_filtered,
mods = ~ Outcome_type-1,
random = list(~1 | Study_ID,
~1 | ES_ID,
~1 | Strain),
test = "t",
method = "REML",
sparse = TRUE,
data = db_filtered)
summary(mOT)
r2OT <- round(r2_ml(mOT), 4)
r2OT
#| label: orchard_outcome_type
#| fig-width: 6
#| fig-height: 4
#| warning: false
orchard_plot(mOT,
mod = "Outcome_type",
group = "Study_ID",
xlab = "log response ratio (lnRR)",
angle = 45)
m1C<-contrast_fun(dat=db_filtered,moderator_name = "Outcome_type", V_matrix= VCV_filtered)
# 1. Contrast Function (Run one model only)
# Takes: 1) data frame, 2) moderator column name (quoted), and 3) VCV matrix
contrast_fun <- function(data, moderator_name, VCV){
# Ensure the moderator is treated as a factor
data[[moderator_name]] <- as.factor(data[[moderator_name]])
# Define the formula (Include an intercept for easy contrast estimation later)
formula <- as.formula(paste("yi ~", moderator_name))
# Run the baseline meta-regression model (e.g., Acute is the reference)
model <- rma.mv(formula,
V = V_matrix,
random = list(~1|Study_ID, ~1|ES_ID, ~1| Strain),
test = "t",
data = data,
sparse = TRUE)
return(model)
}
# 2. Function to Get Estimates and Contrasts from ONE model
get_estimate <- function(model, moderator_name) {
# Get names of all levels (in the order R uses for coefficients)
full_names <- levels(as.factor(model$data[[moderator_name]]))
N <- length(full_names)
# --- 1. Get Subgroup Means (The full predicted mean for each level) ---
# Identity matrix for L: 1 at the intercept, 1 at the specific level
L_means <- diag(N) # N x N identity matrix
L_means[, 1] <- 1 # Set Intercept to 1 for all rows (essential for an intercept model)
# The first row is the reference level mean; others are reference + difference
# This tests the absolute mean of each subgroup against zero.
means_preds <- predict(model, newmods = L_means)
# Create results table for means
results_means <- tibble(
Levels = full_names,
Estimate = means_preds$pred,
Lower_CI = means_preds$ci.lb,
Upper_CI = means_preds$ci.ub,
Lower_PI = means_preds$cr.lb,
Upper_PI = means_preds$cr.ub,
Type = "Mean"
)
# --- 2. Get Pairwise Contrasts ---
# Create all unique combinations of levels
combinations <- t(combn(1:N, 2))
# Initialize the L matrix for contrasts
L_contrasts <- matrix(0, nrow = nrow(combinations), ncol = N)
# Fill the L matrix based on the combination indices
# Example: Contrast (2, 4) -> L[i, 2] = 1, L[i, 4] = -1
for (i in 1:nrow(combinations)) {
L_contrasts[i, combinations[i, 1]] <- 1
L_contrasts[i, combinations[i, 2]] <- -1
}
# Test the contrasts using the L matrix and apply Bonferroni correction
contrasts_results <- anova(model, L = L_contrasts, adjust = "bonferroni")
# Create results table for contrasts
results_contrasts <- tibble(
Levels = paste(full_names[combinations[, 1]], full_names[combinations[, 2]], sep = " - "),
Estimate = contrasts_results$beta,
Lower_CI = contrasts_results$ci.lb,
Upper_CI = contrasts_results$ci.ub,
P_value = contrasts_results$pval,
Type = "Contrast"
)
# --- 3. Combine and Return ---
# We need the p-value for the means, which is already in the summary:
pvals_means <- summary(model)$pval[1:N]
results_means <- results_means %>% mutate(P_value = pvals_means)
return(bind_rows(results_means, results_contrasts))
}
m1C<-contrast_fun(dat=db_filtered,moderator_name = "Outcome_type", V_matrix= VCV_filtered)
View(contrast_fun)
m1C<-contrast_fun(dat=db_filtered,moderator_name = "Outcome_type", VCV= VCV_filtered)
m1C<-contrast_fun(dat=db_filtered,moderator_name = "Outcome_type", V= VCV_filtered)
# 1. Contrast Function (Run one model only)
# Takes: 1) data frame, 2) moderator column name (quoted), and 3) VCV matrix
contrast_fun <- function(data, moderator_name, VCV_matrix){
# Ensure the moderator is treated as a factor
data[[moderator_name]] <- as.factor(data[[moderator_name]])
# Define the formula (Include an intercept for easy contrast estimation later)
formula <- as.formula(paste("yi ~", moderator_name))
# Run the baseline meta-regression model (e.g., Acute is the reference)
model <- rma.mv(formula,
V = V_matrix,
random = list(~1|Study_ID, ~1|ES_ID, ~1| Strain),
test = "t",
data = data,
sparse = TRUE)
return(model)
}
m1C<-contrast_fun(dat=db_filtered,moderator_name = "Outcome_type", V_matrix= VCV_filtered)
# 1. Contrast Function (Run one model only)
# Takes: 1) data frame, 2) moderator column name (quoted), and 3) VCV matrix
contrast_fun <- function(data, moderator_name, V_matrix){
# Ensure the moderator is treated as a factor
data[[moderator_name]] <- as.factor(data[[moderator_name]])
# Define the formula (Include an intercept for easy contrast estimation later)
formula <- as.formula(paste("yi ~", moderator_name))
# Run the baseline meta-regression model (e.g., Acute is the reference)
model <- rma.mv(formula,
V = V_matrix,
random = list(~1|Study_ID, ~1|ES_ID, ~1| Strain),
test = "t",
data = data,
sparse = TRUE)
return(model)
}
m1C<-contrast_fun(dat=db_filtered,moderator_name = "Outcome_type", V_matrix= VCV_filtered)
# 1. Contrast Function (Run one model only)
# Takes: 1) data frame, 2) moderator column name (quoted), and 3) VCV matrix
contrast_fun <- function(data, yi_name, moderator_name, V_matrix){
# Ensure the moderator is treated as a factor
data[[moderator_name]] <- as.factor(data[[moderator_name]])
# Define the formula (Include an intercept for easy contrast estimation later)
formula <- as.formula(paste(yi_name, "~", moderator_name))
# Run the baseline meta-regression model (e.g., Acute is the reference)
model <- rma.mv(formula,
V = V_matrix,
random = list(~1|Study_ID, ~1|ES_ID, ~1| Strain),
test = "t",
data = data,
sparse = TRUE)
return(model)
}
m1C<-contrast_fun(dat=db_filtered,moderator_name = "Outcome_type", V_matrix= VCV_filtered)
